<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8"/>
<title>Artech - 博客园</title>
<link type="text/css" rel="stylesheet" href="/bundles/blog-common.css?v=iaIBFyx6Vr94NzNO_3ZPrlgjC7pN1OGR4X2wPvP0lwg1"/>
<link id="MainCss" type="text/css" rel="stylesheet" href="/skins/Custom/bundle-Custom.css?v=Z683z9azGWin6jOfOyAHK6FgPVxm_nmCnl3EFztc2eE1"/>
<link type="text/css" rel="stylesheet" href="/blog/customcss/22886.css?v=p%2fMHr6owEKcXyLecLVaX8hYsLWw%3d"/>
<link title="RSS" type="application/rss+xml" rel="alternate" href="http://www.cnblogs.com/artech/rss"/>
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="http://www.cnblogs.com/artech/rsd.xml"/>
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="http://www.cnblogs.com/artech/wlwmanifest.xml"/>
<script src="http://common.cnblogs.com/script/jquery.js" type="text/javascript"></script>  
<script type="text/javascript">var currentBlogApp = 'artech', cb_enable_mathjax=false;</script>
<script src="/bundles/blog-common.js?v=ykDTFH9FE4CgKmGT6HilV870QfVPxO515wqgmKkq4MU1" type="text/javascript"></script>
</head>
<body>
<a name="top"></a>
<div id="page_begin_html"></div><script>load_page_begin_html();</script>

<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
	<a id="lnkBlogLogo" href="http://www.cnblogs.com/artech/"><img id="blogLogo" src="/Skins/custom/images/logo.gif" alt="返回主页" /></a>			
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle" href="http://www.cnblogs.com/artech/"><img style="margin:0px auto 10px auto" style="width:94px; height:42px" src="http://images.cnblogs.com/cnblogs_com/artech/158198/o_ArtechLogo.png" alt="Artech" /></a></h1>
<h2></h2>



		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="MyLinks1_HomeLink" class="menu" href="http://www.cnblogs.com/">博客园</a></li>
<li><a id="MyLinks1_MyHomeLink" class="menu" href="http://www.cnblogs.com/artech/">首页</a></li>
<li><a id="MyLinks1_NewPostLink" class="menu" rel="nofollow" href="http://i.cnblogs.com/EditPosts.aspx?opt=1">新随笔</a></li>
<li><a id="MyLinks1_ContactLink" class="menu" rel="nofollow" href="http://msg.cnblogs.com/send/Artech">联系</a></li>
<li><a id="MyLinks1_Syndication" class="menu" href="http://www.cnblogs.com/artech/rss">订阅</a>
<!--<a id="MyLinks1_XMLLink" class="aHeaderXML" href="http://www.cnblogs.com/artech/rss"><img src="http://www.cnblogs.com/images/xml.gif" alt="订阅" /></a>--></li>
<li><a id="MyLinks1_Admin" class="menu" rel="nofollow" href="http://i.cnblogs.com/">管理</a></li>
</ul>
		<div class="blogStats">
			
			
<!--done-->
随笔- 556&nbsp;
文章- 2&nbsp;
评论- 22750&nbsp;

			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		

<!--done-->


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_ctl00_ImageLink" href="http://www.cnblogs.com/artech/">置顶随笔</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_ctl00_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/inside-asp-net-mvc-5-framework.html">[置顶]新作《ASP.NET MVC 5框架揭秘》正式出版</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>本书以一个模拟ASP.NET MVC内部运行机制的“迷你版MVC框架”作为开篇，其目的在于将ASP.NET MVC真实架构的“全景”勾勒出来。接下来本书以请求消息在ASP.NET MVC框架内部的流向为主线将相关的知识点串连起来，力求将”黑盒式”的消息处理管道清晰透明地展示在读者面前。相信精读本书的读者一定能够将ASP.NET MVC从接收请求到响应回复的整个流程了然于胸，对包括路由、Controller的激活、Model元数据的解析、Action方法的选择与执行、参数的绑定与验证、过滤器的执行以及View的呈现等相关的机制具有深刻的理解。本书以实例演示的方式介绍了很多与ASP.NET MVC相关的最佳实践，同时还提供了一系列实用性的扩展，相信它们一定能够解决你在真实开发过程中遇到的很多问题。本书最后一章提供的案例不仅仅用于演示实践中的ASP.NET MVC，很多的架构设计方面的东西也包含其中。除此之<a href="http://www.cnblogs.com/artech/p/inside-asp-net-mvc-5-framework.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2014-08-07 15:28 Artech 阅读(30307) 评论(232)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3897290" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
			<div class="postSeparator"></div>
		
			<div class="postTitle">
				<a id="homepage1_HomePageDays_ctl00_DayList_TitleUrl_1" class="postTitle2" href="http://www.cnblogs.com/artech/p/inside-asp-net-web-api-2-framework.html">[置顶]新作《ASP.NET Web API 2框架揭秘》正式出版</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/o_webapi.png" class="desc_img"/>本书以实例演示的方式介绍了很多与ASP.NET Web API相关的最佳实践，同时还提供了一系列实用性的扩展。本书详细讲解了ASP.NET Web API从接收请求到响应回复的整个流程，包括路由、Http Controller的激活、Action方法的选择与执行、参数的绑定与验证、过滤器的执行和安全等相关的机制。除此之外，本书在很多章节还从设计的角度对ASP.NET Web API的架构进行了深入分析，所以可以将本书当作一本架构设计的书来读。虽然与市面上任何一本相关的书相比，本书走得更远并更加近距离地触及到ASP.NET Web API框架的内核，但是就其内容本身来讲却没有涉及太多“高深莫测”的知识点，所以阅读本书不存在太高的门槛。如果你觉得自己对ASP.NET Web API所知甚少，可以利用此书来系统地学习ASP.NET Web API；如果你觉得自己对ASP.NET Web API足够精通，也一<a href="http://www.cnblogs.com/artech/p/inside-asp-net-web-api-2-framework.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2014-07-07 21:07 Artech 阅读(9908) 评论(68)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3830430" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
			<div class="postSeparator"></div>
		
			<div class="postTitle">
				<a id="homepage1_HomePageDays_ctl00_DayList_TitleUrl_2" class="postTitle2" href="http://www.cnblogs.com/artech/archive/2012/05/08/wcf-book.html">[置顶]《WCF全面解析》（上、下册）正式出版</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_WCF.jpg" class="desc_img"/>“全书之写印，实系初稿。有时公私琐务猬集，每写一句，三搁其笔；有时兴会淋漓，走笔疾书，絮絮不休；有时意趣萧索，执笔木坐，草草而止。每写一段，自助覆阅，辄摇其首，觉有大不妥者，即贴补重书，故剪刀浆糊乃不离左右。个中甘苦，只自知之。” 在某个阳光明媚的早晨，我在去上班的公交车上翻看岳南先生的《南渡北归》的时候，看到上面这段董作宾描述自己写作《殷历谱》之甘苦的文字，回想起我写作这本书的经历，不禁感慨万千。我无意将《WCF全面解析》自比煌煌巨著《殷历谱》，只是觉得人同此心，这段文字正好描述我写作此书的状态。<a href="http://www.cnblogs.com/artech/archive/2012/05/08/wcf-book.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2012-05-08 08:05 Artech 阅读(38116) 评论(442)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=2489500" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
			<div class="postSeparator"></div>
		
			<div class="postTitle">
				<a id="homepage1_HomePageDays_ctl00_DayList_TitleUrl_3" class="postTitle2" href="http://www.cnblogs.com/artech/archive/2012/04/10/how-mvc-works.html">[置顶]How ASP.NET MVC Works?</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>在未来的一段时间里，我将撰写一系列关于ASP.NET MVC的文章。这些文章旨在剖析ASP.NET MVC框架底层的运行机制，力求将整个框架这个黑盒转换为百盒，将框架本身进行请求处理的流程完整而清晰地呈现在读者面前，让读者知其然并知其所以然。了解ASP.NET MVC框架本身的原理，不仅仅可以帮助我们更好地进行相关的编程，还能让我们根据项目具体的需求对其进行得心应手地扩展——因为ASP.NET MVC本身是一个极具扩展性的框架。<a href="http://www.cnblogs.com/artech/archive/2012/04/10/how-mvc-works.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2012-04-10 08:11 Artech 阅读(77553) 评论(187)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=2439881" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl00_ImageLink" href="http://www.cnblogs.com/artech/archive/2015/09/16.html">2015年9月16日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/react-demo-radio-button-list.html">初学ReactJS，写了一个RadioButtonList组件</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: ReactJS学习日志<a href="http://www.cnblogs.com/artech/p/react-demo-radio-button-list.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2015-09-16 10:34 Artech 阅读(3780) 评论(12)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=4812461" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl01_ImageLink" href="http://www.cnblogs.com/artech/archive/2015/07/17.html">2015年7月17日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/asp-net-mvc-bug.html">这算是ASP.NET MVC的一个大BUG吗？</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>这是昨天一个同事遇到的问题，我觉得这是一个蛮大的问题，而且应该不是ASP.NET MVC的设计者有意为之，换言之，这可能是ASP.NET MVC的一个大Bug。<a href="http://www.cnblogs.com/artech/p/asp-net-mvc-bug.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2015-07-17 17:18 Artech 阅读(8696) 评论(31)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=4655183" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl02_ImageLink" href="http://www.cnblogs.com/artech/archive/2014/12/09.html">2014年12月9日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/asp-net-5-hello-world-03.html">通过3个Hello World应用来了解ASP.NET 5应用是如何运行的（3）</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>设置自定义的入口程序体现应用本身与应用托管之间的分离，它使我们可以创建独立于托管环境的应用，并根据需要寄宿于任何一个我们希望的宿主程序下，对于Web应用来说这一点尤为重要。对于之前的Web应用来说，IIS是它们唯一的宿主，但是ASP.NET 5应用却可以将我们指定的入口程序作为宿主。如果将应用寄宿于我们指定的宿主程序，这样的寄宿方式被称为Self-Host，接下来我们通过一个具体的例子来演示如何定义一个简单的ASP.NET MVC应用，并采用Self-Host的方式启动它。<a href="http://www.cnblogs.com/artech/p/asp-net-5-hello-world-03.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2014-12-09 09:25 Artech 阅读(10537) 评论(31)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=4152461" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl03_ImageLink" href="http://www.cnblogs.com/artech/archive/2014/12/08.html">2014年12月8日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl03_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/asp-net-5-hello-world-02.html">通过3个Hello World应用来了解ASP.NET 5应用是如何运行的（2）</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>对于上面创建的这个Hello World应用来说，程序入口点由应用自身来提供，所以应用本身具有自我执行的能力。从应用托管（Host）的角度来讲，这样的应用同时负责对自身的托管。将应用与托管环境独立起来其实是更好的选择，因为这样可以使同一个应用运行于不同的环境中。接下来我们就来演示如何为应用指定入口程序来达到应用与应用托管的分离。<a href="http://www.cnblogs.com/artech/p/asp-net-5-hello-world-02.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2014-12-08 17:37 Artech 阅读(5490) 评论(21)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=4151611" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
			<div class="postSeparator"></div>
		
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl03_DayList_TitleUrl_1" class="postTitle2" href="http://www.cnblogs.com/artech/p/asp-net-5-hello-world-01.html">通过3个Hello World应用来了解ASP.NET 5应用是如何运行的（1）</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>微软在开发ASP.NET 5（当时被称为ASP.NET vNext）是采用的代号为Project K，所以运行时被称为KRuntime。KRuntime是一个SDK，它包含了编译和运行应用程序的所有资源。接下来我们通过三个Hello World实例来演示如何利用KRuntime让我们编写的应用运行起来。这三个实例如此的简单，以至于我们根本不需要利用IDE来编写。作为第一个Hello World应用，我们会编写一个包含入口点的程序，并通过执行KRuntime的K.cmd命令来启动它。<a href="http://www.cnblogs.com/artech/p/asp-net-5-hello-world-01.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2014-12-08 10:47 Artech 阅读(9432) 评论(23)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=4150561" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl04_ImageLink" href="http://www.cnblogs.com/artech/archive/2014/08/18.html">2014年8月18日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl04_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/book-as-a-present-2.html">感恩回馈，新鲜出炉的《ASP.NET MVC 5框架揭秘》免费赠送</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>上次针对《ASP.NET Web API 2框架揭秘》举办了一次评论赠书活动，很多人问我相同的活动要不要针对《ASP.NET MVC 5框架揭秘》再来一次，为此我向出版社要了10本，其中5本以评论博客的形式送出，另5本则以转发微博的形式送出.<a href="http://www.cnblogs.com/artech/p/book-as-a-present-2.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2014-08-18 11:51 Artech 阅读(10645) 评论(1373)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3919199" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl05_ImageLink" href="http://www.cnblogs.com/artech/archive/2014/08/14.html">2014年8月14日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl05_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/inside-asp-net-mvc-5-framework-demo.html">《ASP.NET MVC 5框架揭秘》样章发布</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>今天算是新作《ASP.NET MVC 5框架揭秘》正式上架销售的日子（目前本书在互动网已经到货），为了让更多适合的朋友们能够阅读此书，同时也避免让不适合的读者误买此书，特将此书的样章发布出来。<a href="http://www.cnblogs.com/artech/p/inside-asp-net-mvc-5-framework-demo.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2014-08-14 21:37 Artech 阅读(8725) 评论(101)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3913503" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl06_ImageLink" href="http://www.cnblogs.com/artech/archive/2014/08/07.html">2014年8月7日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl06_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/inside-asp-net-mvc-5-framework.html">新作《ASP.NET MVC 5框架揭秘》正式出版</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>本书以一个模拟ASP.NET MVC内部运行机制的“迷你版MVC框架”作为开篇，其目的在于将ASP.NET MVC真实架构的“全景”勾勒出来。接下来本书以请求消息在ASP.NET MVC框架内部的流向为主线将相关的知识点串连起来，力求将”黑盒式”的消息处理管道清晰透明地展示在读者面前。相信精读本书的读者一定能够将ASP.NET MVC从接收请求到响应回复的整个流程了然于胸，对包括路由、Controller的激活、Model元数据的解析、Action方法的选择与执行、参数的绑定与验证、过滤器的执行以及View的呈现等相关的机制具有深刻的理解。本书以实例演示的方式介绍了很多与ASP.NET MVC相关的最佳实践，同时还提供了一系列实用性的扩展，相信它们一定能够解决你在真实开发过程中遇到的很多问题。本书最后一章提供的案例不仅仅用于演示实践中的ASP.NET MVC，很多的架构设计方面的东西也包含其中。除此之<a href="http://www.cnblogs.com/artech/p/inside-asp-net-mvc-5-framework.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2014-08-07 15:28 Artech 阅读(30307) 评论(232)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3897290" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl07_ImageLink" href="http://www.cnblogs.com/artech/archive/2014/07/14.html">2014年7月14日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl07_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/book-as-a-present.html">感恩回馈，《ASP.NET Web API 2框架揭秘》免费赠送</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/o_webapi.png" class="desc_img"/>在继《WCF全面解析》、《ASP.NET MVC 4框架揭秘》之后，我的另一本书《ASP.NET Web API 2框架揭秘》于本月正式出版，《ASP.NET MVC 5框架揭秘》也即将推出。这几本上算畅销的技术书籍的出版源于多年写博客的积累，所以离不开博客园这个平台和广大网友的支持。作为回馈，我也学学汤姆大叔来一个评论送书活动。<a href="http://www.cnblogs.com/artech/p/book-as-a-present.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2014-07-14 08:15 Artech 阅读(12409) 评论(3469)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3842017" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl08_ImageLink" href="http://www.cnblogs.com/artech/archive/2014/07/07.html">2014年7月7日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl08_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/inside-asp-net-web-api-2-framework-sample.html">《ASP.NET Web API 2框架揭秘》样章（PDF版本）</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/o_webapi.png" class="desc_img"/>《ASP.NET Web API 2框架揭秘》以实例演示的方式介绍了很多与ASP.NET Web API相关的最佳实践，同时还提供了一系列实用性的扩展。本书详细讲解了ASP.NET Web API从接收请求到响应回复的整个流程，包括路由、Http Controller的激活、Action方法的选择与执行、参数的绑定与验证、过滤器的执行和安全等相关的机制。<a href="http://www.cnblogs.com/artech/p/inside-asp-net-web-api-2-framework-sample.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2014-07-07 22:21 Artech 阅读(10632) 评论(113)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3830533" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
			<div class="postSeparator"></div>
		
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl08_DayList_TitleUrl_1" class="postTitle2" href="http://www.cnblogs.com/artech/p/inside-asp-net-web-api-2-framework.html">新作《ASP.NET Web API 2框架揭秘》正式出版</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/o_webapi.png" class="desc_img"/>本书以实例演示的方式介绍了很多与ASP.NET Web API相关的最佳实践，同时还提供了一系列实用性的扩展。本书详细讲解了ASP.NET Web API从接收请求到响应回复的整个流程，包括路由、Http Controller的激活、Action方法的选择与执行、参数的绑定与验证、过滤器的执行和安全等相关的机制。除此之外，本书在很多章节还从设计的角度对ASP.NET Web API的架构进行了深入分析，所以可以将本书当作一本架构设计的书来读。虽然与市面上任何一本相关的书相比，本书走得更远并更加近距离地触及到ASP.NET Web API框架的内核，但是就其内容本身来讲却没有涉及太多“高深莫测”的知识点，所以阅读本书不存在太高的门槛。如果你觉得自己对ASP.NET Web API所知甚少，可以利用此书来系统地学习ASP.NET Web API；如果你觉得自己对ASP.NET Web API足够精通，也一<a href="http://www.cnblogs.com/artech/p/inside-asp-net-web-api-2-framework.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2014-07-07 21:07 Artech 阅读(9908) 评论(68)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3830430" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl09_ImageLink" href="http://www.cnblogs.com/artech/archive/2014/04/29.html">2014年4月29日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl09_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/asp-net-mvc-4-validation.html">ASP.NET MVC下的四种验证编程方式[续篇]</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>在《ASP.NET MVC下的四种验证编程方式》一文中我们介绍了ASP.NET MVC支持的四种服务端验证的编程方式（“手工验证”、“标注ValidationAttribute特性”、“让数据类型实现IValidatableObject或者IDataErrorInfo”），那么在ASP.NET MVC框架内部是如何提供针对这四种不同编程方式的支持的呢？接下来我们就来聊聊这背后的故事。<a href="http://www.cnblogs.com/artech/p/asp-net-mvc-4-validation.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2014-04-29 08:44 Artech 阅读(6419) 评论(22)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3698441" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl10_ImageLink" href="http://www.cnblogs.com/artech/archive/2014/04/17.html">2014年4月17日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl10_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/reflect-vs-expression.html">比较一下以&ldquo;反射&rdquo;和&ldquo;表达式&rdquo;执行方法的性能差异</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Dotnet.png" class="desc_img"/>由于频繁地使用反射会影响性能，所以ASP.NET MVC采用了表达式树的方式来执行目标Action方法。具体来说，ASP.NET MVC会构建一个表达式来体现针对目标Action方法的执行，并且将该表达式编译成可执行代码。编译后的可执行代码体现为一个委托对象，该委托对象会被缓存起来以用于针对同一个Action方法的执行。为了让大家能够和直观地理解两种（直接利用反射和利用表达式编译后的委托对象）方法执行在性能上的差异，我们来做一个简单的实例演示<a href="http://www.cnblogs.com/artech/p/reflect-vs-expression.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2014-04-17 08:44 Artech 阅读(6716) 评论(31)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3669916" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl11_ImageLink" href="http://www.cnblogs.com/artech/archive/2014/04/16.html">2014年4月16日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl11_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/authentication-filter.html">[ASP.NET MVC] 利用自定义的AuthenticationFilter实现Basic认证</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>很多情况下目标Action方法都要求在一个安全上下文中被执行，这里所谓的安全上下文主要指的是当前请求者是一个经过授权的用户。授权的本质就是让用户在他许可的权限范围内做他能够做的事情，授权的前提是请求者是一个经过认证的用户。质询-应答（Chanllenge-Response）”是用户认证采用的一种常用的形式，认证方向被认证方发出质询以要求其提供用于实施认证的用户凭证，而被认证方提供相应的凭证以作为对质询的应答。旨在目标Action方法执行之前实施身分认证的AuthenticationFilter也对这种认证方法提供了支持。<a href="http://www.cnblogs.com/artech/p/authentication-filter.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2014-04-16 09:21 Artech 阅读(6762) 评论(22)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3667890" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl12_ImageLink" href="http://www.cnblogs.com/artech/archive/2014/04/15.html">2014年4月15日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl12_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/ioc-4-asp-net-web-api.html">IoC在ASP.NET Web API中的应用</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>控制反转（Inversion of Control，IoC），简单地说，就是应用本身不负责依赖对象的创建和维护，而交给一个外部容器来负责。这样控制权就由应用转移到了外部IoC容器，控制权就实现了所谓的反转。比如在类型A中需要使用类型B的实例，而B实例的创建并不由A来负责，而是通过外部容器来创建。通过IoC的方式实现针对目标HttpController的激活具有重要的意义。<a href="http://www.cnblogs.com/artech/p/ioc-4-asp-net-web-api.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2014-04-15 07:53 Artech 阅读(7645) 评论(27)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3665348" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl13_ImageLink" href="http://www.cnblogs.com/artech/archive/2014/04/14.html">2014年4月14日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl13_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/asp-net-web-api-active-release-controller.html">总体介绍ASP.NET Web API下Controller的激活与释放流程</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>通过《ASP.NET Web API的Controller是如何被创建的？》我们已经对HttpController激活系统的核心对象有了深刻的了解，在这篇文章中，对我们对此作一个总结。除此之外，本篇文章还会涉及一个大家极易忽视的问题——Controller是如何释放的？<a href="http://www.cnblogs.com/artech/p/asp-net-web-api-active-release-controller.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2014-04-14 08:41 Artech 阅读(3422) 评论(5)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3663212" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl14_ImageLink" href="http://www.cnblogs.com/artech/archive/2014/04/10.html">2014年4月10日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl14_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/custom-assembly-resolver.html">[ASP.NET Web API]如何Host定义在独立程序集中的Controller</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>ASP.NET Web API在Self Host寄宿模式下用于解析程序集的AssembliesResolver是一个DefaultAssembliesResolver对象，它只会提供当前应用程序域已经加载的程序集。如果我们将HttpController定义在非寄宿程序所在的程序集中，即使我们将它们部属在宿主程序运行的目录中，宿主程序启动的时候也不会主动去加载这些程序集。由于当前应用程序域中并不曾加载这些程序集，HttpController类型解析将会失败，HttpController的激活自然就无法实现。<a href="http://www.cnblogs.com/artech/p/custom-assembly-resolver.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2014-04-10 22:50 Artech 阅读(2873) 评论(10)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3657622" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
			<div class="postSeparator"></div>
		
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl14_DayList_TitleUrl_1" class="postTitle2" href="http://www.cnblogs.com/artech/p/http-controller-how-to-activate.html">ASP.NET Web API的Controller是如何被创建的？</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>Web API调用请求的目标是定义在某个HttpController类型中的某个Action方法，所以消息处理管道最终需要激活目标HttpController对象。调用请求的URI会携带目标HttpController的名称，该名称经过路由解析之后会作为路由变量保存到一个HttpRouteData对象中，而后者会被添加到代表当前请求的HttpRequestMessage对象的属性字典中。ASP.NET Web API据此解析出目标HttpController的类型，进而实现针对目标HttpController实例的激活。<a href="http://www.cnblogs.com/artech/p/http-controller-how-to-activate.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2014-04-10 07:26 Artech 阅读(4988) 评论(14)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3655611" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl15_ImageLink" href="http://www.cnblogs.com/artech/archive/2014/04/08.html">2014年4月8日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl15_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/asp-net-mvc-validation-programming.html">ASP.NET MVC下的四种验证编程方式</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>ASP.NET MVC采用Model绑定为目标Action生成了相应的参数列表，但是在真正执行目标Action方法之前，还需要对绑定的参数实施验证以确保其有效性，我们将针对参数的验证成为Model绑定。总地来说，我们可以采用4种不同的编程模式来进行针对绑定参数的验证。<a href="http://www.cnblogs.com/artech/p/asp-net-mvc-validation-programming.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2014-04-08 09:03 Artech 阅读(18263) 评论(51)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3651232" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl16_ImageLink" href="http://www.cnblogs.com/artech/archive/2014/04/01.html">2014年4月1日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl16_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/cache-sliding-time-1-second.html">[ASP.NET] 如果将缓存&ldquo;滑动过期时间&rdquo;设置为1秒会怎样？</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>今天编写了一个采用ASP.NET Caching的组件，在为它编写Unit Test的过程中发现了一个有趣的问题...<a href="http://www.cnblogs.com/artech/p/cache-sliding-time-1-second.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2014-04-01 19:09 Artech 阅读(4291) 评论(17)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3639016" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl17_ImageLink" href="http://www.cnblogs.com/artech/archive/2014/03/21.html">2014年3月21日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl17_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/httpcontroller.html">ASP.NET Web API中的Controller</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>虽然通过Visual Studio向导在ASP.NET Web API项目中创建的 Controller类型默认派生与抽象类型ApiController，但是ASP.NET Web API框架本身只要求它实现IHttpController接口即可，所以我们将其统称为HttpController。<a href="http://www.cnblogs.com/artech/p/httpcontroller.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2014-03-21 09:17 Artech 阅读(7436) 评论(15)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3615134" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl18_ImageLink" href="http://www.cnblogs.com/artech/archive/2014/03/20.html">2014年3月20日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl18_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/self-host-how-to-work.html">Self Host模式下的ASP. NET Web API是如何进行请求的监听与处理的？</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>构成ASP.NET Web API核心框架的消息处理管道既不关心请求消息来源于何处，也不需要考虑响应消息归于何方。当我们采用Web Host模式将一个ASP.NET应用作为目标Web API的宿主时，实际上是由ASP.NET管道解决了这两个问题。具体来说，ASP.NET自身的URL路由系统借助于HttpControllerHandler这个自定义的HttpHandler实现了ASP.NET管道和ASP.NET Web API管道之间的“连通”，但是在Self Host寄宿模式下，请求的监听、接收和响应又是如何实现的呢？<a href="http://www.cnblogs.com/artech/p/self-host-how-to-work.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2014-03-20 11:44 Artech 阅读(4383) 评论(5)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3613334" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl19_ImageLink" href="http://www.cnblogs.com/artech/archive/2014/03/18.html">2014年3月18日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl19_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/x-http-method-override.html">如果调用ASP.NET Web API不能发送PUT/DELETE请求怎么办？</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>理想的RESTful Web API采用面向资源的架构，并使用请求的HTTP方法表示针对目标资源的操作类型。但是理想和现实是有距离的，虽然HTTP协议提供了一系列原生的HTTP方法，但是在具体的网络环境中，很多是不支持的。比如有的浏览器只能发送GET和POST请求，客户端发送的PUT请求也不一定能够被服务器理解。除了客户端和服务器对请求采用的HTTP方法的制约外，像代理（Proxy）、网管（Gateway）等这些中间部件都具有针对HTTP方法的限制。<a href="http://www.cnblogs.com/artech/p/x-http-method-override.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2014-03-18 08:51 Artech 阅读(6287) 评论(18)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3606873" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl20_ImageLink" href="http://www.cnblogs.com/artech/archive/2014/03/17.html">2014年3月17日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl20_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/asp-net-web-api-pipeline.html">ASP.NET Web API标准的&ldquo;管道式&rdquo;设计</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>ASP.NET Web API的核心框架是一个消息处理管道，这个管道是一组HttpMessageHandler的有序组合。这是一个双工管道，请求消息从一端流入并依次经过所有HttpMessageHandler的处理。在另一端，目标HttpController被激活，Action方法被执行，响应消息随之被生成。响应消息逆向流入此管道，同样会经过逐个HttpMessageHandler的处理。这是一个独立于寄宿环境的抽象管道，如何实现对请求的监听与接收，以及将接收的请求传入消息处理管道进行处理并将管道生成的响应通过网络回传给客户端，这就是Web API寄宿需要解决的问题。<a href="http://www.cnblogs.com/artech/p/asp-net-web-api-pipeline.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2014-03-17 07:40 Artech 阅读(5968) 评论(17)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3604400" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl21_ImageLink" href="http://www.cnblogs.com/artech/archive/2014/03/14.html">2014年3月14日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl21_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/web-api-sample.html">在一个空ASP.NET Web项目上创建一个ASP.NET Web API 2.0应用</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>Visual Studio为我们提供了专门用于创建ASP.NET Web API应用的项目模板，借助于此项目模板提供的向导，我们可以“一键式”创建一个完整的ASP.NET Web API项目。在项目创建过程中，VS会自动为我们添加必要的程序集引用和配置，甚至会为我们自动生成相关的代码。对于IDE提供的这种旨在提高生产效率的自动化机制，我个人自然是推崇的，但是我更推荐读者朋友们去了解一下这些自动化机制具体为我们做了什么？做这些的目的何在？哪些是必需的，哪些又是不必要的？正是基于这样的目的，在接下来演示的实例中，我们将摒弃VS为我们提供的向导，完全在创建的空项目中编写我们的程序。<a href="http://www.cnblogs.com/artech/p/web-api-sample.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2014-03-14 10:26 Artech 阅读(18655) 评论(48)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3599974" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl22_ImageLink" href="http://www.cnblogs.com/artech/archive/2014/01/06.html">2014年1月6日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl22_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/restful-web-api-02.html">我所理解的RESTful Web API [设计篇]</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Architecture.png" class="desc_img"/>2000年，Roy Thomas Fielding博士在他那篇著名的博士论文《Architectural Styles and the Design of Network-based Software Architectures》中提出了一种软件应用的架构风格。REST是“REpresentational State Transfer”的缩写，可以翻译成“表现状态转换”。<a href="http://www.cnblogs.com/artech/p/restful-web-api-02.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2014-01-06 07:48 Artech 阅读(53176) 评论(26)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3506553" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl23_ImageLink" href="http://www.cnblogs.com/artech/archive/2014/01/05.html">2014年1月5日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl23_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/restful-web-api-01.html">我所理解的RESTful Web API [Web标准篇]</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Architecture.png" class="desc_img"/>REST不是一个标准，而是一种软件应用架构风格。基于SOAP的Web服务采用RPC架构，如果说RPC是一种面向操作的架构风格，而REST则是一种面向资源的架构风格。REST是目前业界更为推崇的构建新一代Web服务（或者Web API）的架构风格。由于REST仅仅是一种价格风格，所以它是与具体的技术平台无关的，也就是说采用REST架构的应用未必一定建立在Web之上，所以在正式介绍REST之前，我们先来简单认识一下Web。<a href="http://www.cnblogs.com/artech/p/restful-web-api-01.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2014-01-05 19:10 Artech 阅读(15606) 评论(17)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3506143" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl24_ImageLink" href="http://www.cnblogs.com/artech/archive/2013/12/30.html">2013年12月30日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl24_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/oauth-03.html">谈谈基于OAuth 2.0的第三方认证 [下篇]</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Security.png" class="desc_img"/>从安全的角度来讲，《中篇》介绍的Implicit类型的Authorization Grant存在这样的两个问题：其一，授权服务器没有对客户端应用进行认证，因为获取Access Token的请求只提供了客户端应用的ClientID而没有提供其ClientSecret；其二，Access Token是授权服务器单独颁发给客户端应用的，照理说对于其他人（包括拥有被访问资源的授权者）应该是不可见的。Authorization Code类型的Authorization Grant很好地解决了这两个问题。<a href="http://www.cnblogs.com/artech/p/oauth-03.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2013-12-30 08:55 Artech 阅读(7446) 评论(5)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3497090" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl25_ImageLink" href="http://www.cnblogs.com/artech/archive/2013/12/20.html">2013年12月20日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl25_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/oauth-02.html">谈谈基于OAuth 2.0的第三方认证 [中篇]</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Security.png" class="desc_img"/>虽然我们在《上篇》分别讨论了4种预定义的Authorization Grant类型以及它们各自的适用场景的获取Access Token的方式，我想很多之前没有接触过OAuth 2.0的读者朋友们依然会有“不值所云” 之感，所以在介绍的内容中，我们将采用实例演示的方式对Implicit和Authorization Code这两种常用的Authorization Grant作深入介绍。本章着重介绍Implicit Authorization Grant。<a href="http://www.cnblogs.com/artech/p/oauth-02.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2013-12-20 08:25 Artech 阅读(12843) 评论(9)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3483173" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl26_ImageLink" href="http://www.cnblogs.com/artech/archive/2013/12/19.html">2013年12月19日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl26_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/oauth-01.html">谈谈基于OAuth 2.0的第三方认证 [上篇]</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Security.png" class="desc_img"/>在Internet环境下，我们针对具体的Web应用设计独立的认证系统往往是一件“吃力不讨好”的事情。如果我们开发一个很小的Web应用，可能在实现用户认证功能上面花费的成本比实现应用自身业务功能的成本更大，而且还会因为“信任危机”导致潜在的使用者不敢注册。
在这种情况下，如果一个值得信任的第三方能够提供一种免费的认证服务，那么这两个问题均会迎刃而解。实际上目前这样的第三方认证服务很多，而且他们的提供者均为值得信赖的IT服务提供商，比如微软、Google、Facebook、Twitter，以及国内的新浪、腾讯、网易、人人和豆瓣等。就目前来说，这些第三方认证服务绝大部分均是基于OAuth 2.0设计的。<a href="http://www.cnblogs.com/artech/p/oauth-01.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2013-12-19 09:00 Artech 阅读(10016) 评论(20)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3481445" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl27_ImageLink" href="http://www.cnblogs.com/artech/archive/2013/12/18.html">2013年12月18日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl27_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/cors-4-asp-net-web-api.html">JavaScript跨域调用、JSONP、CORS与ASP.NET Web API[共8篇]</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>同源策略（Same Origin Policy）的存在导致了“源”自A的脚本只能操作“同源”页面的DOM，“跨源”操作来源于B的页面将会被拒绝。同源策略以及跨域资源共享在大部分情况下针对的是Ajax请求。同源策略主要限制了通过XMLHttpRequest实现的Ajax请求，如果请求的是一个“异源”地址，浏览器将不允许读取返回的内容。JSONP和CORS是两种常用的解决方案，本系列文章主要针对两者在ASP.NET Web API的应用展开讨论。<a href="http://www.cnblogs.com/artech/p/cors-4-asp-net-web-api.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2013-12-18 09:44 Artech 阅读(5516) 评论(6)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3479727" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl28_ImageLink" href="http://www.cnblogs.com/artech/archive/2013/12/16.html">2013年12月16日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl28_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/cors-4-asp-net-web-api-08.html">跨域资源共享（CORS）在ASP.NET Web API中是如何实现的？</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>在《通过扩展让ASP.NET Web API支持W3C的CORS规范》中，我们通过自定义的HttpMessageHandler自行为ASP.NET Web API实现了针对CORS的支持，实际上ASP.NET Web API自身也是这么做的，该自定义HttpMessageHandler就是System.Web.Http.Cors.CorsMessageHandler。<a href="http://www.cnblogs.com/artech/p/cors-4-asp-net-web-api-08.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2013-12-16 08:29 Artech 阅读(6268) 评论(16)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3476095" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl29_ImageLink" href="http://www.cnblogs.com/artech/archive/2013/12/13.html">2013年12月13日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl29_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/cors-4-asp-net-web-api-07.html">ASP.NET Web API自身对CORS的支持: CORS授权检验的实施</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>通过《EnableCorsAttribute特性背后的故事》我们知道：由CorsPolicyProvider提供的CorsPolicy表示目标Action采用的资源授权策略，ASP.NET Web API最终需要利用它对具体的跨域资源请求实施授权检验并生成相应的CORS响应报头，而这是通过ASP.NET自身提供的CORS引擎来完成的。<a href="http://www.cnblogs.com/artech/p/cors-4-asp-net-web-api-07.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2013-12-13 08:57 Artech 阅读(3519) 评论(2)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3472412" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl30_ImageLink" href="http://www.cnblogs.com/artech/archive/2013/12/11.html">2013年12月11日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl30_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/cors-4-asp-net-web-api-06.html">ASP.NET Web API自身对CORS的支持: EnableCorsAttribute特性背后的故事</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>从编程的角度来讲，ASP.NET Web API针对CORS的实现仅仅涉及到HttpConfiguration的扩展方法EnableCors和EnableCorsAttribute特性。但是整个CORS体系不限于此，在它们背后隐藏着一系列的类型，我们将会利用本章余下的内容对此作全面讲述，今天我们就来讨论一下用于定义CORS授权策略的EnableCorsAttribute特性背后的故事。<a href="http://www.cnblogs.com/artech/p/cors-4-asp-net-web-api-06.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2013-12-11 09:31 Artech 阅读(4559) 评论(3)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3468648" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl31_ImageLink" href="http://www.cnblogs.com/artech/archive/2013/12/10.html">2013年12月10日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl31_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/cors-4-asp-net-web-api-05.html">ASP.NET Web API自身对CORS的支持：从实例开始</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>在《通过扩展让ASP.NET Web API支持W3C的CORS规范》中我们通过自定义的HttpMessageHandler为ASP.NET Web API赋予了跨域资源共享的能力，实际上ASP.NET Web API本身就提供了针对CORS的支持，就其实现原理来看，与我们的实现没有本质的区别。接下来我们通过实例演示如何利用ASP.NET Web API自身的支持来实现“跨域资源共享”。<a href="http://www.cnblogs.com/artech/p/cors-4-asp-net-web-api-05.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2013-12-10 08:36 Artech 阅读(9463) 评论(17)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3466822" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl32_ImageLink" href="http://www.cnblogs.com/artech/archive/2013/12/09.html">2013年12月9日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl32_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/cors-4-asp-net-web-api-04.html">通过扩展让ASP.NET Web API支持W3C的CORS规范</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>让ASP.NET Web API支持JSONP和W3C的CORS规范是解决“跨域资源共享”的两种途径，在《通过扩展让ASP.NET Web API支持JSONP》中我们实现了前者，并且在《W3C的CORS Specification》一文中我们对W3C的CORS规范进行了详细介绍，现在我们通过一个具体的实例来演示如何利用ASP.NET Web API具有的扩展点来实现针对CORS的支持。<a href="http://www.cnblogs.com/artech/p/cors-4-asp-net-web-api-04.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2013-12-09 09:01 Artech 阅读(6955) 评论(23)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3464635" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl33_ImageLink" href="http://www.cnblogs.com/artech/archive/2013/12/05.html">2013年12月5日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl33_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/cors-4-asp-net-web-api-03.html">通过扩展让ASP.NET Web API支持JSONP</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>同源策略主要限制了通过XMLHttpRequest实现的Ajax请求，如果请求的是一个“异源”地址，浏览器将不允许读取返回的内容。JSONP是一种常用的解决跨域资源共享的解决方案，现在我们利用ASP.NET Web API自身的扩展性提供一种“通用”的JSONP实现方案。<a href="http://www.cnblogs.com/artech/p/cors-4-asp-net-web-api-03.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2013-12-05 23:00 Artech 阅读(9178) 评论(34)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3460544" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl34_ImageLink" href="http://www.cnblogs.com/artech/archive/2013/12/04.html">2013年12月4日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl34_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/cors-4-asp-net-web-api-02.html">[CORS：跨域资源共享] W3C的CORS Specification</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>随着Web开放的程度越来越高，通过浏览器跨域获取资源的需求已经变得非常普遍。在我看来，如果Web API不能针对浏览器提供跨域资源共享的能力，它甚至就不应该被称为Web API。从另一方面来看，浏览器作为进入Internet最大的入口，是各大IT公司的必争之地，所以浏览器市场出现了种类繁多、鱼龙混杂的局面。针对这两点，我们迫切需要一种能够被各个浏览器厂商共同遵循的标准来对跨域资源共享作出规范，这就是由W3C指定2的CORS（Cross-Origin Resource Sharing）规范<a href="http://www.cnblogs.com/artech/p/cors-4-asp-net-web-api-02.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2013-12-04 22:47 Artech 阅读(8100) 评论(6)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3458541" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
			<div class="postSeparator"></div>
		
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl34_DayList_TitleUrl_1" class="postTitle2" href="http://www.cnblogs.com/artech/p/cors-4-asp-net-web-api-01.html">[CORS：跨域资源共享] 同源策略与JSONP</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>Web API普遍采用面向资源的REST架构，将浏览器最终执行上下文的JavaScript应用Web API消费者的重要组成部分。“同源策略”限制了JavaScript的跨站点调用，这必然导致Web API不能垮域提供资源。如果Web API仅限于为“同源客户端”提供资源，那么它都对不起自己的名字，因为Web本身是一个开放的协议。那么ASP.NET Web API通过怎样的方式来实现跨域资源共享呢？<a href="http://www.cnblogs.com/artech/p/cors-4-asp-net-web-api-01.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2013-12-04 10:48 Artech 阅读(16990) 评论(18)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3457116" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>


<div class="day">
	<div class="dayTitle">
		<a id="homepage1_HomePageDays_DaysList_ctl35_ImageLink" href="http://www.cnblogs.com/artech/archive/2013/11/07.html">2013年11月7日</a>				  
	</div>

	
			<div class="postTitle">
				<a id="homepage1_HomePageDays_DaysList_ctl35_DayList_TitleUrl_0" class="postTitle2" href="http://www.cnblogs.com/artech/p/asp-net-web-api-localization.html">如何让ASP.NET Web API的Action方法在希望的Culture下执行</a>
			</div>
			<div class="postCon"><div class="c_b_p_desc">摘要: <img src="http://images.cnblogs.com/cnblogs_com/artech/158198/r_Aspnet.png" class="desc_img"/>在今天编辑推荐的《Hello Web API系列教程——Web API与国际化》，作者通过自定义的HttpMessageHandler的方式根据请求的Accep-Language报头设置当前线程UI Culture的方式来解决Localization的问题。如果你对ASP.NET Web API的执行机制有足够了解的话，你会发现实际上有很多种解决方案。不过这些解决方案都不够完美，原因很简单：ASP.NET Web API的整个框架均采用基于Task的并行编程模式，所以每个可扩展组件均可以在不同的线程中执行，这样会导致我们没有办法100%控制目标方法真正执行的线程的UI Culture。不过在默认情况下，大部分组件是按照同步的方式执行的，所以我们之需要在目标Action方法执行之前设置当前线程的UI Culture即可。<a href="http://www.cnblogs.com/artech/p/asp-net-web-api-localization.html" class="c_b_p_desc_readmore">阅读全文</a></div></div>
			<div class="clear"></div>
			<div class="postDesc">posted @ 2013-11-07 20:12 Artech 阅读(4221) 评论(10)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=3413149" rel="nofollow">编辑</a></div>
			<div class="clear"></div>
		
</div>

<div class="topicListFooter"><div id="nav_next_page"><a href="http://www.cnblogs.com/artech/default.html?page=2">下一页</a></div></div>


	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<!--done-->
<div class="newsItem">
<h3 class="catListTitle">公告</h3>
	<div id="blog-news"></div><script type="text/javascript">loadBlogNews();</script>
</div>

			<div id="blog-calendar" style="display:none"></div><script type="text/javascript">loadBlogDefaultCalendar();</script>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div><script type="text/javascript">loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		
<!--done-->
Copyright &copy;2016 Artech
	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->
<!--PageEndHtml Block Begin-->
<script type="text/javascript">
        $(document).ready(function () {
            $("body").prepend($("#div_digg").css({ "position": "fixed", "right": "0px", "bottom": "0px", "z-index": "10", "background-color": "white", "margin": "10px", "padding": "10px", "border": "1px solid #cccccc" }));
            if ($("#cnblogs_post_body #MySignature").html()) {
                var signature = $("#cnblogs_post_body").next();
                if (signature.attr("id") == "MySignature") {
                    signature.hide();
                }
            }
            else {
                $("#MySignature").html('作者：<a href="http://artech.cnblogs.com/" target="_blank">Artech</a><br />出处：<a href="http://artech.cnblogs.com/" target="_blank">http://artech.cnblogs.com/</a><br />本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。');
            }
        });
    
    </script>
<!--PageEndHtml Block End-->
</body>
</html>
